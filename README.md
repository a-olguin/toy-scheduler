# toy-scheduler
A toy application to run a series of little tasks repeatedly at intervals &amp; offsets measured using linux capabilities. Think about how to nicely handle schedule misses &amp; a basic preemptive strategy for executing close to linux boundaries. This implementation targets repeating the schedule on a 1hz boundary.


The application boils down to two main task: generating / storing the schedule & running it.

THe schedule is implemented as a singly linked list of "events" that all have an execution time offset from the beginning of the schedule, a name, and up to 3 actions that event can perform. Additionally, a lazy priority scheme was implemented with a parallel array of priority enums. To generate the schedule, you add tasks via the add_to_schedule interface, which takes an event, offset, and frequency of the task. The schedule then increments across and adds events to keep the items in time order and adds to existing events if they already exist on a particular offset. For example, two 2hz tasks can be added with different ofsets, say 0 and 0.2, so that the schedule looks like task1(0.0s) -> task2(0.2s) -> task1(0.5s) -> task2(0.7s).

To actually execute the schedule, low level linux/posix timing interfaces are used. The schedule is run with two parameters- a duration and an alignment. THe duration will be infinite set to 0, and however many seconds otherwise. The alignment controls the start of the schedule along the one second increment (the same schedule can be run starting at t=0.0s or t=0.314159s). Once started, it looks at the time until the next offset time and nanosleeps until a ~2ms before, where it enters a busy wait. Note there are occasional deadline misses with this strategy, and for strict timing requiremetns it is perfectly acceptable to change the nanosleep boundary to 0s and simply busy wait until the next execution time comes along. Then, when it's time to execute an event, we check the next event's start time and highest priority. This way, as we're executing the current event, we can short circuit if we run into the deadline and there is a higher priority event waiting. This will drop the unperformed actions, a design decision.